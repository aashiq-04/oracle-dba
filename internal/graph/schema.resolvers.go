package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85 DO NOT EDIT.

import (
	"context"
	"fmt"

	"github.com/aashiq-04/oracle-dba/internal/graph/model"
	"github.com/aashiq-04/oracle-dba/internal/middleware"
	"github.com/google/uuid"
)

// AssignRole is the resolver for the assignRole field.
func (r *mutationResolver) AssignRole(ctx context.Context, userID string, roleID string) (*model.User, error) {
	if err := middleware.RequirePermission(ctx, "MANAGE_USERS"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: AssignRole")
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
	if err := middleware.RequirePermission(ctx, "MANAGE_USERS"); err != nil {
		return nil, err
	}
	
	roleIDs := make([]uuid.UUID, len(input.RoleIds))
	for i, idStr := range input.RoleIds {
		roleID, err := uuid.Parse(idStr)
		if err != nil {
			return nil, fmt.Errorf("invalid role ID: %w", err)
		}
		roleIDs[i] = roleID
	}

	user, err := r.authService.CreateUser(ctx, input.Username, input.Email, input.Password, roleIDs)
	if err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	roles, err := r.rbacService.GetUserRoles(ctx, user.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user roles: %w", err)
	}

	graphqlRoles := make([]*model.Role, len(roles))
	for i, role := range roles {
		graphqlRoles[i] = &model.Role{
			ID:          role.ID.String(),
			Name:        role.Name,
			Description: role.Description,
		}
	}

	return &model.User{
		ID:        user.ID.String(),
		Username:  user.Username,
		Email:     user.Email,
		IsActive:  user.IsActive,
		Roles:     graphqlRoles,
		LastLogin: user.LastLogin,
		CreatedAt: user.CreatedAt,
	}, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, userID string) (bool, error) {
	if err := middleware.RequirePermission(ctx, "MANAGE_USERS"); err != nil {
		return false, err
	}
	return false, fmt.Errorf("not implemented: DeleteUser")
}

// KillSession is the resolver for the killSession field.
func (r *mutationResolver) KillSession(ctx context.Context, sid int, serial int) (bool, error) {
	if err := middleware.RequirePermission(ctx, "SESSION_KILL"); err != nil {
		return false, err
	}
	return false, fmt.Errorf("not implemented: KillSession - would execute ALTER SYSTEM KILL SESSION")
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	loginResp, err := r.authService.Login(ctx, input.Username, input.Password)
	if err != nil {
		return nil, fmt.Errorf("login failed: %w", err)
	}

	roles := make([]*model.Role, len(loginResp.Roles))
	for i, role := range loginResp.Roles {
		roles[i] = &model.Role{
			ID:          role.ID.String(),
			Name:        role.Name,
			Description: role.Description,
		}
	}

	return &model.AuthPayload{
		Token: loginResp.Token,
		User: &model.User{
			ID:        loginResp.User.ID.String(),
			Username:  loginResp.User.Username,
			Email:     loginResp.User.Email,
			IsActive:  loginResp.User.IsActive,
			Roles:     roles,
			LastLogin: loginResp.User.LastLogin,
			CreatedAt: loginResp.User.CreatedAt,
		},
		ExpiresAt: loginResp.ExpiresAt,
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	if _, err := middleware.RequireAuth(ctx); err != nil {
		return false, err
	}
	return true, nil
}

// RevokeRole is the resolver for the revokeRole field.
func (r *mutationResolver) RevokeRole(ctx context.Context, userID string, roleID string) (*model.User, error) {
	if err := middleware.RequirePermission(ctx, "MANAGE_USERS"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: RevokeRole")
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.User, error) {
	if err := middleware.RequirePermission(ctx, "MANAGE_USERS"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: UpdateUser")
}

// ActiveSessions is the resolver for the activeSessions field.
func (r *queryResolver) ActiveSessions(ctx context.Context, filter *model.SessionFilterInput) ([]*model.OracleSession, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_SESSIONS"); err != nil {
		return nil, err
	}

	userCtx := middleware.MustGetUserFromContext(ctx)
	sessions, err := r.oracleService.GetActiveSessions(ctx, userCtx.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get active sessions: %w", err)
	}

	result := make([]*model.OracleSession, len(sessions))
	for i, session := range sessions {
		status := model.SessionStatus(session.Status)
		result[i] = &model.OracleSession{
			Sid:             session.SID,
			Serial:          session.Serial,
			Username:        session.Username,
			SchemaName:      session.SchemaName,
			OsUser:          session.OSUser,
			Machine:         session.Machine,
			Program:         session.Program,
			Status:          status,
			SQLID:           session.SQLID,
			SQLText:         session.SQLText,
			LogonTime:       session.LogonTime,
			LastCallSeconds: session.LastCallET,
			BlockingSession: session.BlockingSession,
			WaitClass:       session.WaitClass,
			Event:           session.Event,
			SecondsInWait:   session.SecondsInWait,
		}
	}

	return result, nil
}

// AuditLog is the resolver for the auditLog field.
func (r *queryResolver) AuditLog(ctx context.Context, id string) (*model.AuditLog, error) {
	if err := middleware.RequirePermission(ctx, "AUDIT_READ"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: AuditLog")
}

// AuditLogs is the resolver for the auditLogs field.
func (r *queryResolver) AuditLogs(ctx context.Context, filter *model.AuditLogFilterInput, limit int, offset int) ([]*model.AuditLog, error) {
	if err := middleware.RequirePermission(ctx, "AUDIT_READ"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: AuditLogs")
}

// BlockingSessions is the resolver for the blockingSessions field.
func (r *queryResolver) BlockingSessions(ctx context.Context) ([]*model.BlockingSession, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_LOCKS"); err != nil {
		return nil, err
	}

	userCtx := middleware.MustGetUserFromContext(ctx)
	blockingSessions, err := r.oracleService.GetBlockingSessions(ctx, userCtx.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get blocking sessions: %w", err)
	}

	result := make([]*model.BlockingSession, len(blockingSessions))
	for i, bs := range blockingSessions {
		blockingStatus := model.SessionStatus(bs.BlockingStatus)
		result[i] = &model.BlockingSession{
			BlockingSid:            bs.BlockingSID,
			BlockingSerial:         bs.BlockingSerial,
			BlockingUser:           bs.BlockingUser,
			BlockingSchema:         bs.BlockingSchema,
			BlockingStatus:         blockingStatus,
			BlockingSQLID:          bs.BlockingSQLID,
			BlockingSQLText:        bs.BlockingSQLText,
			BlockedSid:             bs.BlockedSID,
			BlockedSerial:          bs.BlockedSerial,
			BlockedUser:            bs.BlockedUser,
			BlockedSchema:          bs.BlockedSchema,
			BlockedWaitClass:       bs.BlockedWaitClass,
			BlockedEvent:           bs.BlockedEvent,
			BlockedDurationSeconds: bs.BlockedDurationSeconds,
			BlockedSQLText:         bs.BlockedSQLText,
		}
	}

	return result, nil
}

// DatabaseInstance is the resolver for the databaseInstance field.
func (r *queryResolver) DatabaseInstance(ctx context.Context) (*model.DatabaseInstance, error) {
	if _, err := middleware.RequireAuth(ctx); err != nil {
		return nil, err
	}

	userCtx := middleware.MustGetUserFromContext(ctx)
	instance, err := r.oracleService.GetDatabaseInstance(ctx, userCtx.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get database instance: %w", err)
	}

	return &model.DatabaseInstance{
		InstanceName:   instance.InstanceName,
		HostName:       instance.HostName,
		Version:        instance.Version,
		StartupTime:    instance.StartupTime,
		Status:         instance.Status,
		DatabaseStatus: instance.DatabaseStatus,
		InstanceRole:   instance.InstanceRole,
		UptimeDays:     instance.UptimeDays,
	}, nil
}

// DatabaseSize is the resolver for the databaseSize field.
func (r *queryResolver) DatabaseSize(ctx context.Context) (*model.DatabaseSize, error) {
	if _, err := middleware.RequireAuth(ctx); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: DatabaseSize")
}

// InvalidObjects is the resolver for the invalidObjects field.
func (r *queryResolver) InvalidObjects(ctx context.Context, schemaName *string) ([]*model.InvalidObject, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_SCHEMA"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: InvalidObjects")
}

// Locks is the resolver for the locks field.
func (r *queryResolver) Locks(ctx context.Context, schemaName *string) ([]*model.LockInfo, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_LOCKS"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: Locks")
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userCtx, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.authService.GetUserByID(ctx, userCtx.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	roles, err := r.rbacService.GetUserRoles(ctx, userCtx.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user roles: %w", err)
	}

	graphqlRoles := make([]*model.Role, len(roles))
	for i, role := range roles {
		graphqlRoles[i] = &model.Role{
			ID:          role.ID.String(),
			Name:        role.Name,
			Description: role.Description,
		}
	}

	return &model.User{
		ID:        user.ID.String(),
		Username:  user.Username,
		Email:     user.Email,
		IsActive:  user.IsActive,
		Roles:     graphqlRoles,
		LastLogin: user.LastLogin,
		CreatedAt: user.CreatedAt,
	}, nil
}

// Permissions is the resolver for the permissions field.
func (r *queryResolver) Permissions(ctx context.Context) ([]*model.Permission, error) {
	if _, err := middleware.RequireAuth(ctx); err != nil {
		return nil, err
	}

	permissions, err := r.rbacService.GetAllPermissions(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get permissions: %w", err)
	}

	result := make([]*model.Permission, len(permissions))
	for i, perm := range permissions {
		result[i] = &model.Permission{
			ID:          perm.ID.String(),
			Code:        perm.Code,
			Description: perm.Description,
		}
	}
	return result, nil
}

// RecentSchemaChanges is the resolver for the recentSchemaChanges field.
func (r *queryResolver) RecentSchemaChanges(ctx context.Context, schemaName *string, days int) ([]*model.SchemaChange, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_SCHEMA"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: RecentSchemaChanges")
}

// Roles is the resolver for the roles field.
func (r *queryResolver) Roles(ctx context.Context) ([]*model.Role, error) {
	if _, err := middleware.RequireAuth(ctx); err != nil {
		return nil, err
	}

	roles, err := r.rbacService.GetAllRoles(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get roles: %w", err)
	}

	result := make([]*model.Role, len(roles))
	for i, role := range roles {
		result[i] = &model.Role{
			ID:          role.ID.String(),
			Name:        role.Name,
			Description: role.Description,
		}
	}
	return result, nil
}

// SchemaInfo is the resolver for the schemaInfo field.
func (r *queryResolver) SchemaInfo(ctx context.Context, name string) (*model.SchemaInfo, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_SCHEMA"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: SchemaInfo")
}

// Schemas is the resolver for the schemas field.
func (r *queryResolver) Schemas(ctx context.Context) ([]*model.SchemaInfo, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_SCHEMA"); err != nil {
		return nil, err
	}

	userCtx := middleware.MustGetUserFromContext(ctx)
	schemas, err := r.oracleService.GetSchemas(ctx, userCtx.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get schemas: %w", err)
	}

	result := make([]*model.SchemaInfo, len(schemas))
	for i, schema := range schemas {
		result[i] = &model.SchemaInfo{
			SchemaName:     schema.SchemaName,
			TotalObjects:   schema.TotalObjects,
			TableCount:     schema.TableCount,
			IndexCount:     schema.IndexCount,
			ViewCount:      schema.ViewCount,
			ProcedureCount: schema.ProcedureCount,
			FunctionCount:  schema.FunctionCount,
			PackageCount:   schema.PackageCount,
		}
	}
	return result, nil
}

// Session is the resolver for the session field.
func (r *queryResolver) Session(ctx context.Context, sid int) (*model.OracleSession, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_SESSIONS"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: Session")
}

// SessionSummary is the resolver for the sessionSummary field.
func (r *queryResolver) SessionSummary(ctx context.Context) (*model.SessionSummary, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_SESSIONS"); err != nil {
		return nil, err
	}

	userCtx := middleware.MustGetUserFromContext(ctx)
	sessions, err := r.oracleService.GetAllSessions(ctx, userCtx.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get sessions: %w", err)
	}

	summary := &model.SessionSummary{
		TotalSessions:    len(sessions),
		ActiveSessions:   0,
		InactiveSessions: 0,
		BlockedSessions:  0,
		BySchema:         []*model.SessionsBySchema{},
	}

	schemaMap := make(map[string]*model.SessionsBySchema)
	for _, session := range sessions {
		if session.Status == "ACTIVE" {
			summary.ActiveSessions++
		} else {
			summary.InactiveSessions++
		}
		if session.BlockingSession != nil {
			summary.BlockedSessions++
		}
		if session.SchemaName != nil {
			schemaName := *session.SchemaName
			if _, exists := schemaMap[schemaName]; !exists {
				schemaMap[schemaName] = &model.SessionsBySchema{
					SchemaName: schemaName,
					Total:      0,
					Active:     0,
					Inactive:   0,
				}
			}
			schemaMap[schemaName].Total++
			if session.Status == "ACTIVE" {
				schemaMap[schemaName].Active++
			} else {
				schemaMap[schemaName].Inactive++
			}
		}
	}

	for _, schemaStats := range schemaMap {
		summary.BySchema = append(summary.BySchema, schemaStats)
	}

	return summary, nil
}

// Sessions is the resolver for the sessions field.
func (r *queryResolver) Sessions(ctx context.Context, filter *model.SessionFilterInput) ([]*model.OracleSession, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_SESSIONS"); err != nil {
		return nil, err
	}

	userCtx := middleware.MustGetUserFromContext(ctx)
	var sessions []*model.OracleSession
	
	// Get all sessions and filter in memory (simplified)
	allSessions, err := r.oracleService.GetAllSessions(ctx, userCtx.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get sessions: %w", err)
	}

	for _, session := range allSessions {
		status := model.SessionStatus(session.Status)
		sessions = append(sessions, &model.OracleSession{
			Sid:             session.SID,
			Serial:          session.Serial,
			Username:        session.Username,
			SchemaName:      session.SchemaName,
			OsUser:          session.OSUser,
			Machine:         session.Machine,
			Program:         session.Program,
			Status:          status,
			SQLID:           session.SQLID,
			SQLText:         session.SQLText,
			LogonTime:       session.LogonTime,
			LastCallSeconds: session.LastCallET,
			BlockingSession: session.BlockingSession,
			WaitClass:       session.WaitClass,
			Event:           session.Event,
			SecondsInWait:   session.SecondsInWait,
		})
	}

	return sessions, nil
}

// SqlByID is the resolver for the sqlById field.
func (r *queryResolver) SQLByID(ctx context.Context, sqlID string) (*model.SQLPerformance, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_SQL"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: SqlByID")
}

// SqlHistory is the resolver for the sqlHistory field.
func (r *queryResolver) SQLHistory(ctx context.Context, sqlID string, timeRange model.TimeRangeInput) ([]*model.SQLMetric, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_SQL"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: SqlHistory")
}

// SqlPerformance is the resolver for the sqlPerformance field.
func (r *queryResolver) SQLPerformance(ctx context.Context, filter *model.SQLPerformanceFilterInput) ([]*model.SQLPerformance, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_SQL"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: SqlPerformance")
}

// Tablespace is the resolver for the tablespace field.
func (r *queryResolver) Tablespace(ctx context.Context, name string) (*model.Tablespace, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_TABLESPACES"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: Tablespace")
}

// TablespaceGrowth is the resolver for the tablespaceGrowth field.
func (r *queryResolver) TablespaceGrowth(ctx context.Context, name string, days int) (*model.TablespaceGrowth, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_TABLESPACES"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: TablespaceGrowth")
}

// TablespaceHistory is the resolver for the tablespaceHistory field.
func (r *queryResolver) TablespaceHistory(ctx context.Context, name string, timeRange model.TimeRangeInput) ([]*model.TablespaceMetric, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_TABLESPACES"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: TablespaceHistory")
}

// Tablespaces is the resolver for the tablespaces field.
func (r *queryResolver) Tablespaces(ctx context.Context, filter *model.TablespaceFilterInput) ([]*model.Tablespace, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_TABLESPACES"); err != nil {
		return nil, err
	}

	userCtx := middleware.MustGetUserFromContext(ctx)
	tablespaces, err := r.oracleService.GetTablespaces(ctx, userCtx.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get tablespaces: %w", err)
	}

	result := make([]*model.Tablespace, len(tablespaces))
	for i, ts := range tablespaces {
		contents := model.TablespaceContents(ts.Contents)
		result[i] = &model.Tablespace{
			Name:            ts.Name,
			TotalSizeMb:     ts.TotalSizeMB,
			UsedSizeMb:      ts.UsedSizeMB,
			FreeSizeMb:      ts.FreeSizeMB,
			UsagePercentage: ts.UsagePercentage,
			Status:          ts.Status,
			Contents:        contents,
			DatafileCount:   ts.DatafileCount,
		}
	}

	return result, nil
}

// TopSQLByCPUTime is the resolver for the topSQLByCPUTime field.
func (r *queryResolver) TopSQLByCPUTime(ctx context.Context, limit int) ([]*model.SQLPerformance, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_SQL"); err != nil {
		return nil, err
	}

	userCtx := middleware.MustGetUserFromContext(ctx)
	sqlPerf, err := r.oracleService.GetTopSQLByCPU(ctx, userCtx.UserID, limit)
	if err != nil {
		return nil, fmt.Errorf("failed to get top SQL by CPU: %w", err)
	}

	result := make([]*model.SQLPerformance, len(sqlPerf))
	for i, sp := range sqlPerf {
		result[i] = &model.SQLPerformance{
			SQLID:          sp.SQLID,
			SQLText:        *sp.SQLText,
			SchemaName:     sp.ParsingSchema,
			ParsingSchema:  sp.ParsingSchema,
			Executions:     sp.Executions,
			ElapsedTimeMs:  sp.ElapsedSeconds * 1000,
			AvgElapsedMs:   sp.AvgElapsedSeconds * 1000,
			CPUTimeMs:      sp.CPUSeconds * 1000,
			AvgCPUMs:       0,
			DiskReads:      sp.DiskReads,
			BufferGets:     sp.BufferGets,
			RowsProcessed:  sp.RowsProcessed,
			FirstLoadTime:  sp.FirstLoadTime,
			LastActiveTime: sp.LastActiveTime,
		}
	}
	return result, nil
}

// TopSqlByDiskReads is the resolver for the topSqlByDiskReads field.
func (r *queryResolver) TopSQLByDiskReads(ctx context.Context, limit int) ([]*model.SQLPerformance, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_SQL"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: TopSqlByDiskReads")
}

// TopSQLByElapsedTime is the resolver for the topSQLByElapsedTime field.
func (r *queryResolver) TopSQLByElapsedTime(ctx context.Context, limit int) ([]*model.SQLPerformance, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_SQL"); err != nil {
		return nil, err
	}

	userCtx := middleware.MustGetUserFromContext(ctx)
	sqlPerf, err := r.oracleService.GetTopSQLByElapsedTime(ctx, userCtx.UserID, limit)
	if err != nil {
		return nil, fmt.Errorf("failed to get top SQL by elapsed time: %w", err)
	}

	result := make([]*model.SQLPerformance, len(sqlPerf))
	for i, sp := range sqlPerf {
		result[i] = &model.SQLPerformance{
			SQLID:          sp.SQLID,
			SQLText:        *sp.SQLText,
			SchemaName:     sp.ParsingSchema,
			ParsingSchema:  sp.ParsingSchema,
			Executions:     sp.Executions,
			ElapsedTimeMs:  sp.ElapsedSeconds * 1000,
			AvgElapsedMs:   sp.AvgElapsedSeconds * 1000,
			CPUTimeMs:      sp.CPUSeconds * 1000,
			AvgCPUMs:       0,
			DiskReads:      sp.DiskReads,
			BufferGets:     sp.BufferGets,
			RowsProcessed:  sp.RowsProcessed,
			FirstLoadTime:  sp.FirstLoadTime,
			LastActiveTime: sp.LastActiveTime,
		}
	}
	return result, nil
}

// TopSqlByExecutions is the resolver for the topSqlByExecutions field.
func (r *queryResolver) TopSQLByExecutions(ctx context.Context, limit int) ([]*model.SQLPerformance, error) {
	if err := middleware.RequirePermission(ctx, "VIEW_SQL"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: TopSqlByExecutions")
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	if err := middleware.RequirePermission(ctx, "MANAGE_USERS"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: User")
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	if err := middleware.RequirePermission(ctx, "MANAGE_USERS"); err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("not implemented: Users")
}

// BlockingDetected is the resolver for the blockingDetected field.
func (r *subscriptionResolver) BlockingDetected(ctx context.Context) (<-chan *model.BlockingSession, error) {
	panic(fmt.Errorf("not implemented: BlockingDetected - blockingDetected"))
}

// SessionAdded is the resolver for the sessionAdded field.
func (r *subscriptionResolver) SessionAdded(ctx context.Context) (<-chan *model.OracleSession, error) {
	panic(fmt.Errorf("not implemented: SessionAdded - sessionAdded"))
}

// TablespaceAlert is the resolver for the tablespaceAlert field.
func (r *subscriptionResolver) TablespaceAlert(ctx context.Context, threshold float64) (<-chan *model.Tablespace, error) {
	panic(fmt.Errorf("not implemented: TablespaceAlert - tablespaceAlert"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }